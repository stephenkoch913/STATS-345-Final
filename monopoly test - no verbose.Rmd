---
title: "Monopoly Test"
output: html_document
---


---
title: "STAT 345 Final Project - Real Estate"
author: "STAT 345 - Braden Barglind, Adam Steckbauer, Stephen Koch, Douglas Klister"
output: html_document
---

Expected Submission: You will generate a well-written R Markdown report that addresses the following prompts. This R Markdown report should source your analysis code and only display top-level, abstracted code _if/when appropriate_. Choices made during the analysis project should be described and justified in the report. You will present on your results during the final exam period for the semester. The written report (knitted file), presentation file, and your analysis code should be submitted to D2L by Tuesday, May 14 at 12:15pm. 

**General advice:** Get started early. If you wait to the last minute, it will not go well. For this project, you may find yourself spending a reasonable amount of time _searching_ for help.

1. _Rules!_ Monopoly has several rules related to movement around the game board. Movement is affected by standard dice rolls, special conditions for some dice rolls, and game cards. Find and summarize these rules. 

2. _Let's Get Moving_ Build a system that allows for up to 4 players to move around the game board. As a first attempt, focus on standard dice rolls, ignoring additional rules related to rolling doubles, jail, or special cards. Which properties are landed on most frequently? Create a visualization for this!

3. _Double Down_ Improve your system to incorporate going to jail, including the doubles-rolling condition. Which properties are landed on most frequently now? Has this changed dramatically from the previous system (that didn't account for jail)? Again, visualize this!

4. _Take a Chance_ Incorporate the movement cards into your system. You can ignore the effects of non-movement cards, but not their existence! Which properties are landed on most frequently now? Has this changed dramatically from the previous system (that didn't account for Chance)? Again, visualize this!

5. _Play a Game_ Extend your system to allow for up to 4 players to "play" the game. You may choose a reasonable starting board and player money level (so, you don't have to buy properties). Include payments between players, payments to the bank, and payments from the bank (there are several cards that will effect these that you should account for). You do not need to consider mortgaging properties (so a player loses when their liquid cash has run out). How long do games typically last given your starting board and money level? How does this change if money paid to the bank is placed in "Free Parking" and awarded to players landing on that space?

******************
```{r}
#Libraries
library(tidyverse)
library(jtools)
```

```{r}
#Monopoly Board Vector
monopoly_board <- data.frame(space = 1:40, title = c("Go", "Mediterranean Avenue", "Community Chest 1", "Baltic Avenue", "Income Tax", "Reading Railroad", "Oriental Avenue", "Chance 1", "Vermont Avenue", "Connecticut Avenue", "Jail", "St. Charles Place", "Electric Company", "States Avenue", "Virginia Avenue", "Pennsylvania Railroad", "St. James Place", "Community Chest 2", "Tennessee Avenue", "New York Avenue", "Free Parking", "Kentucky Avenue", "Chance 2", "Indiana Avenue", "Illinois Avenue", "B. & O. Railroad", "Atlantic Avenue", "Ventnor Avenue", "Water Works", "Marvin Gardens", "Go to Jail", "Pacific Avenue", "North Carolina Avenue", "Community Chest 3", "Pennsylvania Avenue", "Short Line", "Chance 3", "Park Place", "Luxury Tax", "Boardwalk"), stringsAsFactors = FALSE)
```

```{r}
#Chance Cards Vector
chance_cards <- data.frame(index = 1:16, card = c("Advance to Go", "Advance to Illinois Ave - If you pass Go, collect $200", "Advance to St. Charles Place – If you pass Go, collect $200", "Advance token to nearest Utility. If unowned, you may buy it from the Bank. If owned, throw dice and pay owner a total ten times the amount thrown.", "Advance token to the nearest Railroad and pay owner twice the rental to which he/she {he} is otherwise entitled. If Railroad is unowned, you may buy it from the Bank.", "Bank pays you dividend of $50", "Get Out of Jail Free", "Go Back 3 Spaces", "Go to Jail–Go directly to Jail–Do not pass Go, do not collect $200", "Make general repairs on all your property–For each house pay $25–For each hotel $100", "Pay poor tax of $15", "Take a trip to Reading Railroad–If you pass Go, collect $200", "Take a walk on the Boardwalk–Advance token to Boardwalk", "You have been elected Chairman of the Board–Pay each player $50", "Your building and loan matures—Collect $150", "You have won a crossword competition—Collect $100"))
```
 
 
```{r}
#Community Chest Cards Vector
community_cards <-  data.frame(index = 1:17, card = c("Advance to Go", "Bank error in your favor", "Doctor's fee", "From sale of stock you get $50", "Get Out of Jail Free", "Go to Jail", "Grand Opera Night", "Holiday Fund matures", "Income tax refund", "It is your birthday", "Life insurance matures", "Pay hospital fees", "Pay school fees", "Recieve consultancy fee", "You are assessed for street repairs", "You have won second prize in a beauty", "You inherit $100"))
```

```{r}
#Creating the Dice Rolls
dice <- function(){
  faces <- sample(1:6,2, replace = TRUE)
  if(faces[1] == faces[2]) doubles = TRUE
  else doubles = FALSE
  movement = sum(faces)
  return(list(faces=faces, doubles=doubles, movement=movement))
}
```


```{r}
#Creating the Players
#the setRefClass function allows for the creation of fields (similar to variables) and methods (similar to functions) that are associated with and referenced by the specific player
# the fields (variables) created for the player inlcude: pos - used to track the position of the player
                                                        jail - tracks if the player is in jail and if they are how many turns they have been in jail
                                                        rolldouble - tracks how many doubles have been rolled in a row, if exceeds three, the player is sent to jail
# the methods (functions) created for each player include: move_n - used to add the new roll(s) of the player to the positon to find where the player currently is
                                                           go_to_space_n - used to update the position of the player
                                                           increase_jail - adds one to jail when the player is placed in jail or the player fails to roll doubles when in jail
                                                           reset_jail - resets the variable jail when the player gets out of jail
                                                           increase_double - adds one to the variable double when doubles are rolled
                                                           reset_double - resets the amount of doubles rolled in a row to 0 when the player does not roll doubles
player <- setRefClass("player", fields = list(
  #positon of player on the board
  pos="numeric", 
  
  #if 0, player is not in jail, if greater than 0, represents amount of turns player has been in jail
  jail = "numeric",
  
  # amount of doubles player has rolled in a row
  rolldouble = "numeric"
  ), 
method = list(
moves player by "n" positions and if pos is greater than 40, restarts player at beginning of game board
move_n = function(n){
#adds n which is found by roll of dice to position
pos <<- pos + n
#if position if greater than 40, subtracts 40 to start player at beginning of gameboard
if(pos > 40) pos <<- pos - 40
return(pos)}, 

#sends player to specifc position
go_to_space_n = function(n){
#sets the position of the player to n
pos <<-  n
},

#adds on to jail
increase_jail = function(){
  jail <<- jail + 1
},

#resets jail to 0
reset_jail = function(){
  jail <<- 0
    },

# increases doubles by 1 if doubles are rolled
increase_double = function(){
  rolldouble <<- rolldouble + 1
    },

#resets doubles to 0 if doubles are not rolled
reset_double = function(){
  rolldouble <<- 0
    }
 }
```


```{r}
#Function for the Chance Deck
#called when a player lands on one of the three chance positions
#takes two arguments: player and tracking
#no output but updates the players positons and the tally of the amount of times each positions have been landed on if neccessary
#not all chance cards are taken into account since some are too complicated for this simulation

drawchance <- function(player, tracking) {
#draw finds a number between one and fifteen which represents a specifc chance card by using the sample function
draw <- sample(1:15, 1)

#if the draw is between one and nine, there is movement associated with the chance card which access the if statement
if (draw %in% 1:9) {
  #tracking is increased to record the position which the player has landed on
  tracking$increase_count(player$pos)
  
  #the next 20 lines of code determine which specifc chance card was drawn and how the player is moved based on the chance card drawn
  #based on the card drawn, the go_to_space_n, go_to_jail, or move_n function is accessed
  #if the card drawn is 4 or 5 the current positon is aksed and based on the player's current postion they are moved to a new position
  if (draw == 1){
    player$go_to_space_n(1) }
  if (draw == 2){
    player$go_to_space_n(25) }
  if (draw == 3){
    player$go_to_space_n(12) }
  if (draw == 4){
    if (player$pos == 8){
      player$go_to_space_n(13) }
    if (player$pos == 23){
      player$go_to_space_n(29) }
    if (player$pos == 37){
      player$go_to_space_n(5) }
  }
  if (draw == 5){
    if (player$pos == 8){
      player$go_to_space_n(16) }
    if (player$pos == 23){
      player$go_to_space_n(26) }
    if (player$pos == 37){
      player$go_to_space_n(6) }
  }
  if (draw == 6){
    player$go_to_space_n(6) }
  if (draw == 7){
    player$go_to_space_n(40) }
  if (draw == 8){
    player$go_to_jail() }
  if (draw == 9){
    player$move_n(-3) }
} }
```


```{r}
#Function for the Community Chest Deck
#called when a player lands on one of the three community chest positions
#takes two arguments: player and tracking
#no output but updates the players positons and the tally of the amount of times each positions have been landed on if neccessary
#not all community chest cards are taken into account since some are too complicated for this simulation

community_function <- function(player, tracking) {
#draw finds a number between one and sixteen which represents a specifc chance card by using the sample function
draw <- sample(1:16, 1)

#if the dar is either 1 or 2 the player moves thier position
if (draw %in% 1:2) {
  #the tracking is updated based on the position that the player orignally landed on
  tracking$increase_count(player$pos) }

#if one is drawn the player is sent too the "Go" position
if (draw == 1){
  player$go_to_space_n(1) }
  
#if two is drawn the player is sent too the "Jail" position
if (draw == 2){
  player$go_to_jail() }
}
```


```{r}
#Tracking the Player's Movements
#the setRefClass function allows for the creation of fields (similar to variables) and methods (similar to functions) that are associated with and referenced by the specific player
# the field (variable) include tally - used to keep track of the amount of times each position has been landed on
# the methods (functions) include increase_count - used to increase the tally when a player lands on a new position
tracking <- setRefClass("tracking",
    fields = list(
      #tally is a list of amounts of times each positon has been landed on
      tally = "numeric"
), 
    methods = list(
      #increase_count adds one when each specifc position is landed on by indexing the specifc postions
      increase_count = function(n){
        tally[n] <<- tally[n] + 1
        } 
    ) 
)
```


```{r}
#Initiates Players' Turns
#take turn plays each players turn by calling other applicable functions 
#takes two arguments: player and tracking
#no output but calls functions to update the player's positon and the tally of the amount of times each positions have been landed on

taketurn <- function(player, tracking) {
#roll is set to the number produced byt the function dice
roll <- dice()

#value of doubles (TRUE or FLASE) is set to go_again
go_again <- roll$doubles

# if the doubles id true and player's variable "Jail" is greater than one the player gets out of jail
if (roll$doubles & player$jail) {
#jail is reset to 0
player$reset_jail()

#player moves n positions from the jail based on a new roll
player$move_n(roll$movement)

#doubles are reset to 0
roll$reset_double()

#go_again is set to FLASE to stop player
go_again <- FALSE

#if player rolls doubles and is not in jail, doubles increase until they are sent to jail or fail to roll doubles
} else if(roll$doubles & !player$jail) {

#increase_double is called for the specifc player
player$increase_double()

#if player rolled 3 doubles in a row, the player is sent to jail
if (roll$doubles == 3){
#go to jail and reset double function is called
player$go_to_jail()
roll$reset_double()
#go_again is set to FLASE to stop the player from going
go_again <- FALSE
} else {
#if double sis not at 3, the player continues to roll and play
player$move_n(roll$movement)
} 
} else if ( !roll$doubles & player$jail) {
#get out of jail if 3rd turn in jail
if (player$jail == 3){
player$move_n(roll$movement)
player$reset_jail()
} else {
player$increase_jail()
}
} else if ( !roll$doubles & !player$jail){
player$move_n(roll$movement)
roll$reset_double
}
#draw chance card
if (player$pos %in% c(8,23,37)){
drawchance(player, tracking)
if (player$jail){
go_again <- FALSE
} }
#if player isn't on "go to jail" spot
if (player$pos != 31) {
tracking$increase_count(player$pos)
if (go_again){
taketurn(player, tracking)
} } else {
#go to jail and tally location
player$go_to_jail()
tracking$increase_count(player$pos)
}}
```

```{r}
#Set seed for Unique Simulation
set.seed(12345)
```


```{r}
space_tracking <- tracking$new(tally = rep(0,40))
#Simulating game with 4 players. Simulate 1000 times to ensure a large enough sample and accuracy of the means. Each player has 30 turns in a game on average, according to Google. 

for(i in 1:1000){
  player1 <- player$new(pos = 1, jail = 0, rolldouble = 0)
  player2 <- player$new(pos = 1, jail = 0, rolldouble = 0)
  player3 <- player$new(pos = 1, jail = 0, rolldouble = 0)
  player4 <- player$new(pos = 1, jail = 0, rolldouble = 0)
  for(i in 1:30){
    taketurn(player1, space_tracking)
    taketurn(player2, space_tracking)
    taketurn(player3, space_tracking)
    taketurn(player4, space_tracking)
  }
}

cat("1000 Games Ran \n")
# the results after 100 turns. No rules have been implemented
results <- cbind(monopoly_board, tally = space_tracking$tally)
results <- cbind(results, rel = results$tally/sum(results$tally))
print(results)
sum(results$tally)
arrange(results, desc(rel))
```

